<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android 学习笔记(1)—TextView 文本样式]]></title>
    <url>%2F2019%2F03%2F22%2Fandroid%2FTextView%2Fandroid-learning-notes-1.html</url>
    <content type="text"><![CDATA[在Android中，TextView中文本的样式在Android中，TextView是一个非常重要的控件，用于显示文本，通常我们会在XML文件中使用android:text属性来设置文本，也可以在代码中通过调用textView.setText()方法来设置文本，这种方式设置的文本样式默认是使用robot字体的normal样式。有时因为需求，我们需要改变字体的样式，包括颜色、缩放、可点击性，删除线等，有时需要对TextView中所有的文本设置样式，有时只是需要更改其中某些字体的样式，下面针对不同的需要做下总结。 粗体整体加粗可以使用XML属性、styles、或者themes，也可以使用Spans或HTML标签在XML文件中使用android:textStyle=&quot;bold&quot;属性123456&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="32sp" android:textStyle="bold" /&gt; 或在代码中修改Typeface1myTextView.setTypeface(Typeface.create(myTextView.getTypeface(),Typeface.BOLD)); 或在代码中使用StyleSpan123SpannableString string = new SpannableString("Text with\nBullet point");string.setSpan(new StyleSpan(Typeface.BOLD),0,string.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);myTextView.setText(string); 或在代码中使用HTML标签12String textBold = "&lt;b&gt;text bold&lt;/b&gt;";myTextView.setText(Html.fromHtml(textBold)); 部分加粗可以用HTML标签、Spans或者直接重写TextView的onDraw()方法绘制text。 单一样式 —— 单一样式用于整个TextView中文本单一样式我们可以通过使用XML属性、styles、或者themes 使用XML属性例如：将字体设为粗体，我们可以使用android:textStyle=&quot;bold&quot; 123456&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="32sp" android:textStyle="bold" /&gt; 多种样式 —— 多种样式用于文本、字符或片段等多种样式可以通过HTML标签、Spans或者自定TextView中text的绘制 使用HTML标签Java：12String text = "My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;";myTextView.setText(Html.fromHtml(text)); Kotlin：12val text = "My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"myTextView.text = Html.fromHtml(text) 使用SpansSpans允许你实现多种样式的text例如：您可以利用BulletSpan自定义文本边距、项目符号和项目符号颜色之间的间隙。从android p开始，你甚至可以设置BulletSpan的半径。Java12345678910SpannableString spannable = new SpannableString("My text \nbullet one\nbullet two");spannable.setSpan( new BulletSpan(gapWidthPx, accentColor), /* start index */ 9, /* end index */ 18, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);spannable.setSpan( new BulletSpan(gapWidthPx, accentColor), /* start index */ 20, /* end index */ spannable.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);myTextView.setText(spannable); Kotlin12345678910val spannable = SpannableString("My text \nbullet one\nbullet two")spannable.setSpan( BulletSpan(gapWidthPx, accentColor), /* start index */ 9, /* end index */ 18, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)spannable.setSpan( BulletSpan(gapWidthPx, accentColor), /* start index */ 20, /* end index */ spannable.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)myTextView.text = spannable 在Android P中甚至可以设置BulletSpan的半径：Java code：12345678910SpannableString spannable = new SpannableString("My text \nbullet one\nbullet two");spannable.setSpan( new BulletSpan(gapWidthPx, accentColor), /* start index */ 9, /* end index */ 18, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);spannable.setSpan( new BulletSpan(gapWidthPx, accentColor, bulletRadius), /* start index */ 20, /* end index */ spannable.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);myTextView.setText(spannable); Kotlin code：Kotlin12345678910val spannable = SpannableString("My text \nbullet one\nbullet two")spannable.setSpan( BulletSpan(gapWidthPx, accentColor), /* start index */ 9, /* end index */ 18, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)spannable.setSpan( BulletSpan(gapWidthPx, accentColor, bulletRadius), /* start index */ 20, /* end index */ spannable.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)myTextView.text = spannable 单一样式和多种样式可以混合使用1234&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="@color/blue"/&gt; 123456val spannable = SpannableString(“Text styling”)spannable.setSpan( ForegroundColorSpan(Color.PINK), 0, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)myTextView.text = spannable 非常好的文章https://medium.com/androiddevelopers/spantastic-text-styling-with-spans-17b0c16b4568]]></content>
      <categories>
        <category>Android</category>
        <category>TextView</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一点想法]]></title>
    <url>%2F2019%2F03%2F21%2Funcategorized%2Fa-little-thought.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近一直忙着整理之前堆积的东西，发现并没有想象中的那么顺利，感觉整理一个点很容易，可是想要扩展到面，把相关的内容都整理出来，还是非常不容易的，这让我突然想到，在开发产品的过程中，往往会发现，产品经理对某些功能定义不全，导致开发不下去的情况，或许并不是不认真或者不专业，只是在那个当下，他只能想到那么多了。现在的我也遇到了同样的问题，写博客时，当我想把所有的情况都考虑进去的时候，发现脑子一下不够用了，似乎怎么想，都觉得不够全面。不知道是不是整理方式的问题，如果不能大而全，那么点对点可好？采用遇到问题解决问题的方式，嗯，决定试试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android plurals源码分析]]></title>
    <url>%2F2019%2F03%2F21%2Fandroid%2Fsource-code%2Fandroid-source-plurals.html</url>
    <content type="text"><![CDATA[由于不同语言对数量的语法规则不同，所以引入了plurals这种资源，plurals中quality的值有zero,one,two,few,many,和other，当时我们发现，有时我们定义的有些quality在调用是并不能得到预期的结果，这是因为不是所有的语言都能支持所有的quality值，而在我们调用getQuantityString(@PluralsRes int id, int quantity)方式时，系统是怎么返回的，需要从源码着手去分析。 我们从Android 8.0中frameworks/base/core/java/android/content/res/Resources.java的代码入手：1234567891011121314151617@NonNullpublic String getQuantityString(@PluralsRes int id, int quantity, Object... formatArgs) throws NotFoundException &#123; //容易看出，先根据quantity决定要使用的字符串 String raw = getQuantityText(id, quantity).toString(); //再进行占位符的替换工作 return String.format(mResourcesImpl.getConfiguration().getLocales().get(0), raw, formatArgs);&#125;@NonNullpublic CharSequence getQuantityText(@PluralsRes int id, int quantity) throws NotFoundException &#123; //依赖于ResourceImpl的实现 return mResourcesImpl.getQuantityText(id, quantity);&#125; 跟进ResourceImpl中的getQuantityText函数：1234567891011121314151617181920212223CharSequence getQuantityText(@PluralsRes int id, int quantity) throws NotFoundException &#123; //得到规则 PluralRules rule = getPluralRule(); //rule.select根据规则，得到quantity对应的QuanitiyCode，即&quot;zero&quot;、&quot;one&quot;、&quot;other&quot;等 //之后再根据QuanitiyCode，的到具体的资源文件 CharSequence res = mAssets.getResourceBagText(id, attrForQuantityCode(rule.select(quantity))); if (res != null) &#123; return res; &#125; //rule没能找到对应的QuanitiyCode时，就用&quot;other&quot;字段的定义 res = mAssets.getResourceBagText(id, ID_OTHER); if (res != null) &#123; return res; &#125; //上面寻找资源文件出问题，就抛出异常 throw new NotFoundException(&quot;Plural resource ID #0x&quot; + Integer.toHexString(id) + &quot; quantity=&quot; + quantity + &quot; item=&quot; + rule.select(quantity));&#125; 这里我们首先看一下getPluralRule函数：123456789private PluralRules getPluralRule() &#123; synchronized (sSync) &#123; if (mPluralRule == null) &#123; //单例模式，以Locales的第一个配置来初始化规则，而Locales中的第一个即为当前系统的语言，故和本地化有关。 mPluralRule = PluralRules.forLocale(mConfiguration.getLocales().get(0)); &#125; return mPluralRule; &#125;&#125; PluralRules的select函数对应的底层实现，不同的Locales应该有不同的实现。 在此看看attrForQuantityCode：12345678910private static int attrForQuantityCode(String quantityCode) &#123; switch (quantityCode) &#123; case PluralRules.KEYWORD_ZERO: return 0x01000005; case PluralRules.KEYWORD_ONE: return 0x01000006; case PluralRules.KEYWORD_TWO: return 0x01000007; case PluralRules.KEYWORD_FEW: return 0x01000008; case PluralRules.KEYWORD_MANY: return 0x01000009; default: return ID_OTHER; &#125;&#125; 从上面的代码可以看出，PluralRules的select函数的作用，就是将quantity映射成PluralRules定义的Keyword。然后attrForQuantityCode将Keyword转化成资源文件能识别的标志。]]></content>
      <categories>
        <category>Android</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>plurals</tag>
        <tag>本地化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android String用法汇总]]></title>
    <url>%2F2019%2F03%2F20%2Fandroid%2Fandroid-string.html</url>
    <content type="text"><![CDATA[[toc] 改变部分字符的颜色TextSpannablehtml有时需要对TextView中的text做局部的样式改变，加粗或斜体等，由于Android可以兼容部分html标签，故可以在res/strings.xml文件中借助html标签去实现，常用的标签如下： 加粗字体 斜体字体 给字体加下划线\n 换行\u0020表示空格\u2026表示省略号 例如我们要给部分字体加粗，可以这样写：1&lt;string name=&quot;text_part_style&quot;&gt;加粗&lt;b&gt;重点&lt;/b&gt;两个字&lt;/string&gt; 然后直接在xml文件中引用1234567&lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:fontFamily=&quot;@font/abril_fatface&quot; android:text=&quot;@string/text_part_style&quot; android:textSize=&quot;30sp&quot; /&gt; 也可以在代码中引用：1textView.setText(Html.fromHtml(&quot;Hello &lt;b&gt;World&lt;/b&gt;,&lt;font size=\&quot;3\&quot; color=\&quot;red\&quot;&gt;AnalysisXmlActivty!&lt;/font&gt;&quot;)); 设置类似于html那样的效果。 有时Android不能很好的区分标签中的&lt;和&gt;，故需要用它们的实体代替&amp;lt;代表&lt;,&amp;gt;代表&gt;.例如设置a&gt;b,html常用实体：|显示结果 |描述 |实体名称 |实体编号||—|—|—|—|| |空格 |\&nbsp; |\&#160;||&lt; |小于号 |\&lt; |\&#60;||&gt; |大于号 |\&gt; |\&#62;||&amp; |和号 |\&amp; |\&#38;||” |引号 |\&quot; |\&#34;||’ |撇号 |\&apos; (IE不支持) |\&#39;||￠ |分（cent） |\&cent; |\&#162;||£ |镑（pound） |\&pound; |\&#163;|¥ |元（yen） |\&yen; |\&#165;|€ |欧元（euro） |\&euro; |\&#8364;|§ |小节 |\&sect; |\&#167;|© |版权（copyright） |\&copy; |\&#169;|® |注册商标 |\&reg; |\&#174;|™ |商标 |\&trade; |\&#8482;|× |乘号 |\&times; |\&#215;|÷ |除号 |\&divide; |\&#247; 占位符Android支持以占位符的方式，定义字符串。这里要先了解%n$d、%n$f和%n$s是和含义举个例子：1&lt;string name=&quot;old&quot;&gt;%1$s今年%2$d岁了&lt;/string&gt; %1$s: %1表示第一个可替换的变量 $s表示变量是string型%2$d: %2表示第二个可替换的变量 $d 表示变量是整型还有一个$f表示的是浮点型，目前android支持者三种类型的变量如果想要在变量前加空格的，拿整型举例：1&lt;string name=&quot;old&quot;&gt;%1$s今年%2$md岁了&lt;/string&gt; 其中$md 中的m代表m个空格，其它的同理；那么，如何在中使用%号呢？有两个办法： 用%%来表示1个%，和转意符号 \ 的用法相同 如果你的字符串不需要格式化，可以在你的&lt;string 标签上增加一个属性:formatted=”false”例如 &lt;string name=&quot;test&quot; formatted=&quot;false&quot;&gt;% test %&lt;/string&gt;即可。 在使用该字符串时，可以在运行时动态替换占位符号，例如：12String str =getResources().getString(R.string.old_); String string = str.format(str, &quot;李小姐&quot;,27); xliff什么是xliff，参见百度百科 在写xliff之前 一定要引用xliff的命名空间,不引用xliff是无效的:1&lt;resources xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; xliff例子：1&lt;string name=&quot;old_&quot;&gt;&lt;xliff:g id=&quot;name&quot;&gt;%1$s&lt;/xliff:g&gt;今年&lt;xliff:g id=&quot;age&quot;&gt;%2$d&lt;/xliff:g&gt;岁了&lt;/string&gt; 代码中:12String str =getResources().getString(R.string.old_); String string = str.format(str, &quot;李小姐&quot;,27); 输出结果：1李小姐今年27岁了 xliff文件和普通文件的区别1、具有命名空间xmlns:xliff=”urn:oasis:names:tc:xliff:document:1.2”，这个必须要有。2、在标签中含有xliff:g标签。xliff:g标签介绍：属性id可以随便命名属性example表示举例说明，可以省略%n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格%n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0%n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00 plurals由于不同的语言对数量的语法规定有不同的规则。 例如一小时是one hour, 两小时是two hours。 为了解决后缀的问题，Android引入了plurals 这种资源。 android对数量（单复数）进行处理 它支持zero,one,two,few,many,和other;可以理解plurals为一个数量集合的简单资源，它可以通过name的属性来访问（不是xml文件的name）。这样，你可以把plural资源和其他的简单资源一样放在同一个xml 文件里面，在同一个节点下。quality的值和描述： 值 描述 zero 当前语言需要特别对待0 one 当前语言需要特别对待1 two 当前语言需要特别对待2 few 当前语言需要特别对待few/small，也就是小数量的 many 当前语言需要特别对待many/large，也就是大数量的 other 当前语言没有要求对特定资源进行特殊对待 在工程的values下建一个xml文件 ，或者放在strings文件里也可以:123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources &gt; &lt;plurals name=&quot;hour&quot;&gt; &lt;item quantity=&quot;zero&quot;&gt; zero hour &lt;/item&gt; &lt;item quantity=&quot;one&quot;&gt; one hour &lt;/item&gt; &lt;item quantity=&quot;other&quot;&gt; %d hours &lt;/item&gt; &lt;/plurals&gt; &lt;/resources&gt; name 就是plurals的属性名，其中plurals的Item可以是一个或多个，这就是一个完整的plurals资源文件；（%d代表的是整数）下面是如何使用资源文件：12Resources res = getResources();String string = res.getQuantityString(R.plurals.hour,2,8); 其中，2对应的是quantity=“other”，8对应的是other中占位符的值，也就是几小时。 getQuantityString()方法介绍： /** * Returns the string necessary for grammatically correct pluralization * of the given resource ID for the given quantity. * Note that the string is selected based solely on grammatical necessity, * and that such rules differ between languages. Do not assume you know which string * will be returned for a given quantity. See * &lt;a href=&quot;{@docRoot}guide/topics/resources/string-resource.html#Plurals&quot;&gt;String Resources&lt;/a&gt; * for more detail. * * @param id The desired resource identifier, as generated by the aapt * tool. This integer encodes the package, type, and resource * entry. The value 0 is an invalid identifier. * @param quantity The number used to get the correct string for the current language&apos;s * plural rules. * * @throws NotFoundException Throws NotFoundException if the given ID does not exist. * * @return String The string data associated with the resource, * stripped of styled text information. */ @NonNull **public String getQuantityString(@PluralsRes int id, int quantity) throws NotFoundException { return getQuantityText(id, quantity).toString(); }** /** * Formats the string necessary for grammatically correct pluralization * of the given resource ID for the given quantity, using the given arguments. * Note that the string is selected based solely on grammatical necessity, * and that such rules differ between languages. Do not assume you know which string * will be returned for a given quantity. See * &lt;a href=&quot;{@docRoot}guide/topics/resources/string-resource.html#Plurals&quot;&gt;String Resources&lt;/a&gt; * for more detail. * * &lt;p&gt;Substitution of format arguments works as if using * {@link java.util.Formatter} and {@link java.lang.String#format}. * The resulting string will be stripped of any styled text information. * * @param id The desired resource identifier, as generated by the aapt * tool. This integer encodes the package, type, and resource * entry. The value 0 is an invalid identifier. * @param quantity The number used to get the correct string for the current language&apos;s * plural rules. * @param formatArgs The format arguments that will be used for substitution. * * @throws NotFoundException Throws NotFoundException if the given ID does not exist. * * @return String The string data associated with the resource, * stripped of styled text information. */ @NonNull **public String getQuantityString(@PluralsRes int id, int quantity, Object... formatArgs) throws NotFoundException { }** int id，是我们在string.xml里面写的plurals资源的id;int quantity，是数量的意思，也就是我们取具体item的判断依据,Object… formatArgs参数是占位符的值 但是当我们把quantity的值设为0时，程序并没有像我们期望的那样显示zero hour，这是因为程序运行的时候，具体取的那个item，是取决于当前语言对单复数等形式的定义的。具体可以参见Android plurals源码分析; 如果非要在英文中特殊处理zero的情况，可以借助下面要讲的MessageFormat MessageFormat1.在strings.xml文件中定义hour如下：1&lt;string name=&quot;hour&quot;&gt;&#123;0,choice,0#zero hour|1#One hour|1&lt;&#123;0&#125; hours&#125;&lt;/string&gt; 2.在代码中引用hour1String hour = MessageFormat.format(getSherlockActivity().getString(R.string.hour), number) 更多的例子：例1：123456789101112double[] filelimits = &#123;0,1,2&#125;; String[] filepart = &#123;&quot;are no files&quot;,&quot;is one file&quot;,&quot;are &#123;2&#125; files&quot;&#125;; ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart); Format[] testFormats = &#123;fileform, null, NumberFormat.getInstance()&#125;; MessageFormat pattform = new MessageFormat(&quot;There &#123;0&#125; on &#123;1&#125;&quot;); pattform.setFormats(testFormats); Object[] testArgs = &#123;null, &quot;ADisk&quot;, null&#125;; for (int i = 0; i &lt; 4; ++i) &#123; testArgs[0] = new Integer(i); testArgs[2] = testArgs[0]; System.out.println(pattform.format(testArgs)); &#125; 例2： 1234567891011121314ChoiceFormat fmt = new ChoiceFormat( &quot;-1#is negative| 0#is zero or fraction | 1#is one |1.0&lt;is 1+ |2#is two |2&lt;is more than 2.&quot;);System.out.println(&quot;Formatter Pattern : &quot; + fmt.toPattern());System.out.println(&quot;Format with -INF : &quot; + fmt.format(Double.NEGATIVE_INFINITY));System.out.println(&quot;Format with -1.0 : &quot; + fmt.format(-1.0));System.out.println(&quot;Format with 0 : &quot; + fmt.format(0));System.out.println(&quot;Format with 0.9 : &quot; + fmt.format(0.9));System.out.println(&quot;Format with 1.0 : &quot; + fmt.format(1));System.out.println(&quot;Format with 1.5 : &quot; + fmt.format(1.5));System.out.println(&quot;Format with 2 : &quot; + fmt.format(2));System.out.println(&quot;Format with 2.1 : &quot; + fmt.format(2.1));System.out.println(&quot;Format with NaN : &quot; + fmt.format(Double.NaN));System.out.println(&quot;Format with +INF : &quot; + fmt.format(Double.POSITIVE_INFINITY)); 关于MessageFormat的详细用法可以参见Java的API：MessageFormat或Java中MessageFormat的使用更多string的用法，可以参见android String 资源 你所不知道的]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 字体加载流程分析]]></title>
    <url>%2F2019%2F03%2F20%2Fandroid%2Fsource-code%2Fandroid-source-font-loading.html</url>
    <content type="text"><![CDATA[https://blog.csdn.net/a282255307/article/details/76870441文章中分析的和Android O源码并不匹配，需要具体看看5.0和8.0源码之间的差别https://blog.csdn.net/xiao_nian/article/details/60766475]]></content>
      <categories>
        <category>Android</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android Font,Typeface,FontFamily之间的差别]]></title>
    <url>%2F2019%2F03%2F20%2Fandroid%2Ffont%2Fandroid-difference-between-font-typeface-and-fontfamily.html</url>
    <content type="text"><![CDATA[背景Font和Typeface经常被错误的互换使用。然而它们之间却是有一些不同的。 Font大约在十五世纪，当打印机手工打字时，他们必须从一个巨大的盒子里拿出真正的金属字母、数字和符号。如下图：图1 这个收集字符的容器可以被叫做Font现在，font指的是包含各种字体的数字文件，而不是一盒金属字体。 Typeface图2 Typeface描述了字体中包含的字符的整体外观。如图2是一种New Gothic字体（Font）。 你可能有一个容器装的是News Gothic字体，有一个容器装的是News Gothic Bold字体，一个容器装News Gothic Light字体，每个容器里都是一种News Gothic字体。它们只是拥有不同的厚度（weight），但其定义的特征仍然是相同的。 下图或许可以很好的解释Typeface：图3 typeface通常可以和font family互换。再举个例子： 一个家庭有三胞胎：John Smith, Jack Smith, and Tom Smith。他们拥有相同的样貌，但是体重（weight）不同：一个瘦点儿，另一个胖点儿。他们一起组成了Smith family。 在印刷术上，John，Jack，Tom代表着不同的字体，但是他们一起组成了Smith Typeface Font Family在Android中，font family是一组相关字体的集体，例如Arial字体，那么font family将包含Arial regular，Arial Bold，Arial Itatic，Arial Bold Itatic，Arial Black等字体。 总之：typeface是一种设计，font是一个文件，font family是一个相关字体的文件集合。 参考：Typeface vs Font: What’s the Difference?What’s the Difference Between a Font, a Typeface, and a Font Family?]]></content>
      <categories>
        <category>Android</category>
        <category>字体</category>
      </categories>
      <tags>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android O 在xml文件中引用字体]]></title>
    <url>%2F2019%2F03%2F20%2Fandroid%2Ffont%2Fandroid-o-font-in-xml.html</url>
    <content type="text"><![CDATA[背景Android 8.0（API 26 Oreo）引入了可以在xml文件中配置字体的新功能，在这之前，如果要改变字体样式，需要将字体文件放入Asset文件中，并在代码代码中通过getAsset()的方式，动态改变字体的样式。如果想在4.1（API 16）及更高的版本上使用该功能，需要引用Support Library 26. Android O在xml文件中配置字体本地字体直接在xml文件中引用字体1.在res/文件夹下创建font文件夹，并将字体文件拷到font文件夹下，假设字体文件为：myfont.otf2.在xml文件中通过android:fontFamily属性引用自定义的字体123456&lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Text View&quot; android:fontFamily=&quot;@font/myfont&quot;/&gt; 注：font文件名字只能由小写字母a-z，0-9，下划线_组成。 创建font family字体系列是一组字体文件及其样式和权重详细信息。在Android中，您可以创建一个新的字体系列作为XML资源，并将其作为单个单元访问，而不是将每个样式和权重作为单独的资源引用。通过这样做，系统可以根据您尝试使用的文本样式选择正确的字体。（这里有个疑问，系统是怎么匹配字体的？？？）1.在res/font/路径下，右键新建资源文件lobster.xml2.打开此xml文件定义该字体的所有不同版本，以及其样式和权重属性：1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;font-family xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;font android:fontStyle=&quot;normal&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/lobster_regular&quot; /&gt; &lt;font android:fontStyle=&quot;italic&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/lobster_italic&quot; /&gt;&lt;/font-family&gt; 注：android:fontWeight的值是正数，且是100的倍数，在100和900之间，一般 用400表示regular，700表示bold。2.然后在xml文件像引用普通字体一样引用字体文件：1234&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:fontFamily=&quot;@font/lobster&quot;/&gt; 把font添加到style文件中123&lt;style name=&quot;MyTextAppearance&quot; parent=&quot;@android:style/TextAppearance.Small&quot;&gt; &lt;item name=&quot;android:fontFamily&quot;&gt;@font/lobster&lt;/item&gt;&lt;/style&gt; 在代码中使用font12Typeface typeface = getResources().getFont(R.font.myfont);textView.setTypeface(typeface); 利用Support Library兼容至版本4.1版本（兼容到API 14，因为android:fontFamily是Android 4.1版本引入的） 在app/build.gragle添加dependencies： 1implementation &apos;com.android.support:appcompat-v7:26.0.0&apos; 创建font family文件 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;font-family xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;font app:fontStyle=&quot;normal&quot; app:fontWeight=&quot;400&quot; app:font=&quot;@font/myfont-Regular&quot;/&gt; &lt;font app:fontStyle=&quot;italic&quot; app:fontWeight=&quot;400&quot; app:font=&quot;@font/myfont-Italic&quot; /&gt;&lt;/font-family&gt; 注：需要用到app属性 字体的引用同系统API 在代码中引用字体1Typeface typeface = ResourcesCompat.getFont(context, R.font.myfont); 主要需要用到ResourcesCompat类。 4.1之前的版本自定义字体（只能通过代码引用）1.在项目根目录下，新建assets/fonts/文件夹2.将字体拷贝至文件夹下3.在代码中引用123Typeface tf = Typeface.createFromAsset(getContext().getAssets(), &quot;fonts/myfont.ttf&quot;); TextViev textView = findViewById(R.id.textview);textView.setTypeface(tf); 总结：鉴于以上两种情况，font family文件可以定义成兼容模式（由于现在兼容到4.1版本已经可以覆盖所有的设备，故不再考虑4.1之前的版本）1234567891011121314151617181920&lt;font-family xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;&lt;font android:fontStyle=&quot;normal&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/lobster_regular&quot; app:fontStyle=&quot;normal&quot; app:fontWeight=&quot;400&quot; app:font=&quot;@font/lobster_regular&quot; /&gt; &lt;font android:fontStyle=&quot;italic&quot; android:fontWeight=&quot;400&quot; android:font=&quot;@font/lobster_italic&quot; app:fontStyle=&quot;italic&quot; app:fontWeight=&quot;400&quot; app:font=&quot;@font/lobster_italic&quot; /&gt;&lt;/font-family&gt; 在线字体静态配置打开 app/src/main/res/layout/activity_main.xml选择 Design 面板在 Component Tree 面板中, 打开 textview在 Attributes 面板中, 打开 fontFamily 下拉列表并选择 More Fonts… （你可能需要点击 View all attributes才能看到 fontFamily）选择字体家族 eg.Adamina选择字体样式 eg.Regular勾选Create downloadable font（如果勾选add font to project，字体将直接被下载到res/font/下）点击OK，此时在res/font/下就会有我们想下载的字体。 此时我们的项目会有如下变化 res/font/下多了Adamina.xml文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;font-family xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; app:fontProviderAuthority=&quot;com.google.android.gms.fonts&quot; app:fontProviderPackage=&quot;com.google.android.gms&quot; app:fontProviderQuery=&quot;Adamina&quot; app:fontProviderCerts=&quot;@array/com_google_android_gms_fonts_certs&quot;&gt;&lt;/font-family&gt; app:fontProviderFetchStrategy=”blocking” 属性的作用？？？ res/values/下增加了font_certs.xml和preloaded_fonts.xmlfont_certs.xml:字体提供程序的签名1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;array name=&quot;com_google_android_gms_fonts_certs&quot;&gt; &lt;item&gt;@array/com_google_android_gms_fonts_certs_dev&lt;/item&gt; &lt;item&gt;@array/com_google_android_gms_fonts_certs_prod&lt;/item&gt; &lt;/array&gt; &lt;string-array name=&quot;com_google_android_gms_fonts_certs_dev&quot;&gt; &lt;item&gt; MIIEqDCCA5CgAwIBAgIJANWFuGx90071MA0GCSqGSIb3DQEBBAUAMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTAeFw0wODA0MTUyMzM2NTZaFw0zNTA5MDEyMzM2NTZaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBANbOLggKv+IxTdGNs8/TGFy0PTP6DHThvbbR24kT9ixcOd9W+EaBPWW+wPPKQmsHxajtWjmQwWfna8mZuSeJS48LIgAZlKkpFeVyxW0qMBujb8X8ETrWy550NaFtI6t9+u7hZeTfHwqNvacKhp1RbE6dBRGWynwMVX8XW8N1+UjFaq6GCJukT4qmpN2afb8sCjUigq0GuMwYXrFVee74bQgLHWGJwPmvmLHC69EH6kWr22ijx4OKXlSIx2xT1AsSHee70w5iDBiK4aph27yH3TxkXy9V89TDdexAcKk/cVHYNnDBapcavl7y0RiQ4biu8ymM8Ga/nmzhRKya6G0cGw8CAQOjgfwwgfkwHQYDVR0OBBYEFI0cxb6VTEM8YYY6FbBMvAPyT+CyMIHJBgNVHSMEgcEwgb6AFI0cxb6VTEM8YYY6FbBMvAPyT+CyoYGapIGXMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbYIJANWFuGx90071MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEEBQADggEBABnTDPEF+3iSP0wNfdIjIz1AlnrPzgAIHVvXxunW7SBrDhEglQZBbKJEk5kT0mtKoOD1JMrSu1xuTKEBahWRbqHsXclaXjoBADb0kkjVEJu/Lh5hgYZnOjvlba8Ld7HCKePCVePoTJBdI4fvugnL8TsgK05aIskyY0hKI9L8KfqfGTl1lzOv2KoWD0KWwtAWPoGChZxmQ+nBli+gwYMzM1vAkP+aayLe0a1EQimlOalO762r0GXO0ks+UeXde2Z4e+8S/pf7pITEI/tP+MxJTALw9QUWEv9lKTk+jkbqxbsh8nfBUapfKqYn0eidpwq2AzVp3juYl7//fKnaPhJD9gs= &lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&quot;com_google_android_gms_fonts_certs_prod&quot;&gt; &lt;item&gt; MIIEQzCCAyugAwIBAgIJAMLgh0ZkSjCNMA0GCSqGSIb3DQEBBAUAMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDAeFw0wODA4MjEyMzEzMzRaFw0zNjAxMDcyMzEzMzRaMHQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtHb29nbGUgSW5jLjEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDCCASAwDQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBAKtWLgDYO6IIrgqWbxJOKdoR8qtW0I9Y4sypEwPpt1TTcvZApxsdyxMJZ2JORland2qSGT2y5b+3JKkedxiLDmpHpDsz2WCbdxgxRczfey5YZnTJ4VZbH0xqWVW/8lGmPav5xVwnIiJS6HXk+BVKZF+JcWjAsb/GEuq/eFdpuzSqeYTcfi6idkyugwfYwXFU1+5fZKUaRKYCwkkFQVfcAs1fXA5V+++FGfvjJ/CxURaSxaBvGdGDhfXE28LWuT9ozCl5xw4Yq5OGazvV24mZVSoOO0yZ31j7kYvtwYK6NeADwbSxDdJEqO4k//0zOHKrUiGYXtqw/A0LFFtqoZKFjnkCAQOjgdkwgdYwHQYDVR0OBBYEFMd9jMIhF1Ylmn/Tgt9r45jk14alMIGmBgNVHSMEgZ4wgZuAFMd9jMIhF1Ylmn/Tgt9r45jk14aloXikdjB0MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLR29vZ2xlIEluYy4xEDAOBgNVBAsTB0FuZHJvaWQxEDAOBgNVBAMTB0FuZHJvaWSCCQDC4IdGZEowjTAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBAUAA4IBAQBt0lLO74UwLDYKqs6Tm8/yzKkEu116FmH4rkaymUIE0P9KaMftGlMexFlaYjzmB2OxZyl6euNXEsQH8gjwyxCUKRJNexBiGcCEyj6z+a1fuHHvkiaai+KL8W1EyNmgjmyy8AW7P+LLlkR+ho5zEHatRbM/YAnqGcFh5iZBqpknHf1SKMXFh4dd239FJ1jWYfbMDMy3NS5CTMQ2XFI1MvcyUTdZPErjQfTbQe3aDQsQcafEQPD+nqActifKZ0Np0IS9L9kR/wbNvyz6ENwPiTrjV2KRkEjH78ZMcUQXg0L3BYHJ3lc69Vs5Ddf9uUGGMYldX3WfMBEmh/9iFBDAaTCK &lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; preloaded_fonts.xml:在安装和更新过程中加载的字体列表，以确保这些字体在启动应用程序时可用。123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;array name=&quot;preloaded_fonts&quot; translatable=&quot;false&quot;&gt; &lt;item&gt;@font/adamina&lt;/item&gt; &lt;/array&gt;&lt;/resources&gt; AndroidManifest.xml文件中增加字体的meta-data信息 (meta-data信息的作用？？？？)123&lt;meta-data android:name=&quot;preloaded_fonts&quot; android:resource=&quot;@array/preloaded_fonts&quot; /&gt; 动态加载 我们需要一个线程等待字体，声明一个变量以保存： 1private Handler fontHandler; 添加一个 Method 来管理字体处理线程： 12345678private Handler getFontHandlerThread() &#123; if (fontHandler == null) &#123; HandlerThread handlerThread = new HandlerThread(&quot;fonts&quot;); handlerThread.start(); fontHandler = new Handler(handlerThread.getLooper()); &#125; return fontHandler;&#125; 添加一个 Method 将 Typeface (参考 ) 应用于 Toolbar： 1234567891011private void styleToolbar(Typeface typeface) &#123; // this is gross but toolbar doesn&apos;t expose it&apos;s children for (int i = 0; i &lt; toolbar.getChildCount(); i++) &#123; View rawView = toolbar.getChildAt(i); if (!(rawView instanceof TextView)) &#123; continue; &#125;TextView textView = (TextView) rawView; textView.setTypeface(typeface); &#125;&#125; 在 onCreate 中，从字体提供程序启动异步获取： 123456789101112131415161718192021@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... FontRequest fontRequest = new FontRequest(&quot;com.google.android.gms.fonts&quot;, &quot;com.google.android.gms&quot;, &quot;name=Adamina&quot;, R.array.font_certs); FontsContractCompat.FontRequestCallback toolbarFontCallback = new FontsContractCompat.FontRequestCallback() &#123; @Override public void onTypefaceRetrieved(Typeface typeface) &#123; // If we got our font apply it to the toolbar styleToolbar(typeface); &#125; @Override public void onTypefaceRequestFailed(int reason) &#123; Log.w(TAG, &quot;Failed to fetch Toolbar font: &quot; + reason); &#125; &#125;; // Start async fetch on the handler thread FontsContractCompat.requestFont(this, fontRequest, toolbarFontCallback, getFontHandlerThread()); 关于字体，想了解更多的，可以查看Android 字体]]></content>
      <categories>
        <category>Android</category>
        <category>字体</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown教程]]></title>
    <url>%2F2019%2F03%2F20%2FMarkdown%2FMarkdown.html</url>
    <content type="text"><![CDATA[基础篇 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题 文本样式12345678910111213- 链接：[title](url)- 加粗：**文本**- 斜体：*ABC*- 高亮：==高亮==- 段落：段落之间空一行- 换行符：一行结束时输入两个空格- 列表： - 无序列表 - 有序列表- 引用： &gt;引用内容- 内嵌代码：`code`- 分割线：---或***或===- 方框： - [ ] - 链接：title 加粗：文本 斜体：ABC 粗斜体：粗斜体文本 高亮：==高亮== 段落：段落之间空一行 换行符：一行结束时输入两个空格 列表： 无序列表 有序列表 引用： &gt;引用内容 内嵌代码：code 分割线：—-或**或=== 方框：- [ ] - 有序列表数字不能省略但可无序，点号之后的空格不能少123451. 第一项2. 第二项3. 第三项5. 第五项4. 第四项 第一项 第二项 第三项 第五项 第四项 无序列表符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长1234- 无序列表- 无序列表- 无序列表- 无序列表 无序列表 无序列表 无序列表 无序列表 嵌套列表-+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少 无序嵌套123- 第一层 * 第二层 + 第三层 第一层 第二层 第三层 有序无序混套123451. 有序 - 无序列表 + 无序列表2. 有序4. 有序 有序 无序列表 无序列表 有序 有序 图片括号内的url可以是网络路径，也可以是本地路径。本地路径可以是绝对路径，也可以是相对路径，最好取相对路径。1![图片描述（可省略）](url) 分割线三个或更多-_*，必须单独一行，可含空格123---___*** ##代码 内嵌代码将代码放入内（主要不是单引号，是波浪线对应的键）1`代码` 代码 代码块代码放入\内,在第一行后指定编程语言，也可以不指定1``` 代码块 1``` 代码块1234### 高亮代码块中的关键字或方法使用“\```+语言名称” + \“```”进行标记,目前支持的语言有：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir 123456789public static void showDialog(Context context, View view) &#123; AlertDialog alertDialogAddHomeLink = new AlertDialog.Builder(context) .setView(view).create(); Window window = alertDialogAddHomeLink.getWindow(); WindowManager.LayoutParams p = window.getAttributes(); p.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS; window.clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM); window.setAttributes(p); alertDialogAddHomeLink.show(); 12345678910```Java public static void showDialog(Context context, View view) &#123; AlertDialog alertDialogAddHomeLink = new AlertDialog.Builder(context) .setView(view).create(); Window window = alertDialogAddHomeLink.getWindow(); WindowManager.LayoutParams p = window.getAttributes(); p.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS; window.clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM); window.setAttributes(p); alertDialogAddHomeLink.show(); 引用简单引用1&gt;要引用的内容 要引用的内容 引用嵌套1234&gt;第一层内容第一层内容&gt;&gt;第二层内容第二层内容 第一层内容第一层内容 第二层内容第二层内容 注释1&lt;!--注释---&gt; 转义字符转义字符为\，转义的有：1234567891011121314151617181920212223\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号 \ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 表格行首和行尾的竖线可以省略 形式一：默认形式文字默认居左12345|表头|表头|表头||---|---|---||内容内容|内容|内容||内容|内容|内容||内容|内容|内容| 表头 表头 表头 内容内容 内容 内容 内容 内容 内容 内容 内容 内容 形式二：内容居右12345|表头|表头|表头||---:|---|---||内容内容|内容|内容||内容|内容|内容||内容|内容|内容| 表头 表头 表头 内容内容 内容 内容 内容 内容 内容 内容 内容 内容 形式三：内容居中12345|表头|表头|表头||:---:|---|---||内容内容|内容|内容||内容|内容|内容||内容|内容|内容| 表头 表头 表头 内容内容 内容 内容 内容 内容 内容 内容 内容 内容 字体、字号、颜色123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云黑体nullgray 进阶篇 生成目录使用[toc]生成目录，但是有些编辑器不支持，比如简书 注：想在那个位置生成目录，就写在哪个位置，一般在文正的开头。 脚注使用 [^keyword] 表示注脚。 这里是脚注[^n][^n]: 这里是脚注的内容 注：关于注脚好像每个编辑器表示方式会有所不同 待办列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表例如：123- [ ] 起床- [ ] 吃早点- [x] 已完成任务 起床 吃早点 已完成任务 流程图例1123456789```flowst=&gt;start: Starte=&gt;end: Endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 123456789```flowst=&gt;start: Starte=&gt;end: Endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 例21234567891011121314```flow st=&gt;start: 开始 e=&gt;end: 登录 io1=&gt;inputoutput: 输入用户名密码 sub1=&gt;subroutine: 数据库查询子类 cond=&gt;condition: 是否有此用户 cond2=&gt;condition: 密码是否正确 op=&gt;operation: 读入用户信息st-&gt;io1-&gt;sub1-&gt;cond cond(yes,right)-&gt;cond2 cond(no)-&gt;io1(right) cond2(yes,right)-&gt;op-&gt;e cond2(no)-&gt;io1 123456789101112131415```flow st=&gt;start: 开始 e=&gt;end: 登录 io1=&gt;inputoutput: 输入用户名密码 sub1=&gt;subroutine: 数据库查询子类 cond=&gt;condition: 是否有此用户 cond2=&gt;condition: 密码是否正确 op=&gt;operation: 读入用户信息st-&gt;io1-&gt;sub1-&gt;cond cond(yes,right)-&gt;cond2 cond(no)-&gt;io1(right) cond2(yes,right)-&gt;op-&gt;e cond2(no)-&gt;io1 流程图代码分两块，上面一块是创建你的流程（创建元素），然后隔一行，创建流程的走向(连接元素) 创建流程（元素）：tag=&gt;type: content:&gt;url tag 是流程图中的标签，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。 type 用来确定标签的类型，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型 标签有6种类型：start end operation subroutine condition inputoutput content 是流程图文本框中的描述内容，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个空格 url是一个连接，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面 指向流程(连接元素)：标识（类别）-&gt;下一个标识 使用 -&gt; 来连接两个元素 对于condition类型，有yes和no两个分支，如示例中的cond(yes)和cond(no) 每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中cond2(yes,right)。Created with Raphaël 2.1.4开始输入用户名密码数据库查询子类是否有此用户密码是否正确读入用户信息登录yesnoyesno 流程图元素 开始st=&gt;start: 开始 操作op1=&gt;operation: 操作、执行说明 条件cond=&gt;condition: 确认？ 子程序sub1=&gt;subroutine: 子程序操作说明 用户输入或输出io1=&gt;inputoutput: 输入密码 结束e=&gt;end: 结束时序图时序图（Sequence Diagram）用于描述对象之间发送消息的时间顺序或显示多个对象之间的动态协作。时序图中的每条消息对应一个类操作或一个事件。如下所示：12345678``` sequence客户端-&gt;打印机: 打印请求(id)打印机-&gt;数据库:请求数据(id)Note right of 数据库: 执行SQL获取数据数据库--&gt;打印机:返回数据信息Note right of 打印机:使用数据打印打印机--&gt;&gt;客户端:返回打印结果客户端-&gt;客户端:等待提取结果 12345678``` sequence客户端-&gt;打印机: 打印请求(id)打印机-&gt;数据库:请求数据(id)Note right of 数据库: 执行SQL获取数据数据库--&gt;打印机:返回数据信息Note right of 打印机:使用数据打印打印机--&gt;&gt;客户端:返回打印结果客户端-&gt;客户端:等待提取结果 注：Note right/left of 角色 用于定义消息显示的位置 ###时序图元素时序图主要有一下几个元素：角色，对象，生命线，激活器和消息 角色（Actor）任何主体都可以是角色，角色对外发布消息。示例中，客户端，打印机，数据库都是角色。 对象(Object)对象代表时序图中的对象在交互中所扮演的角色，位于时序图顶部和对象代表类角色。有的时候可能有多个打印机 ，那么这些打印机都是同一角色的不同对象 生命线(Lifeline)生命线代表时序图中的对象在一段时期内的存在。时序图中每个对象和底部中心都有一条垂直的线，这就是对象的生命线，对象间 的消息存在于两条虚线间。 激活期(Activation)激活期代表时序图中的对象执行一项操作的时期，在时序图中每条生命线上的窄的矩形代表活动期。它可以被理解成C语言语义中一对花括号“{}”中的内容。csdn的Markdown中并没有这一举行，只能以右侧或左侧的注解来表示“` python 消息(Message)消息是定义交互和协作中交换信息的类，用于对实体间的通信内容建模，信息用于在实体间传递信息。允许实体请求其他的服务，类角色通过发送和接受信息进行通信。 公式行内公式$ 表示行内公式1$E=mc^2$ 行内公式$E=mc^2$ 整行公式\$\$表示整行公式1$$\sum_&#123;i=1&#125;^na_i=0$$ $$\sum_{i=1}^na_i=0$$]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android字体详解]]></title>
    <url>%2F2019%2F03%2F18%2Fandroid%2Ffont%2Fandroid-font.html</url>
    <content type="text"><![CDATA[最近了解了一下字体，发现彻底解释明白这件事情真的很不容易。 android:fontWeight属性值是int，范围是1~1000，系统默认字体的weight是400常用属性值和通常的名字对应关系如下| Value | Common weight name ||——-|——————–||100 |thin|200 |Extra Light(Ultra Light)|300 |Light|400 |Normal(Regular、Book、Roman)|500 |Medium|600 |Semi Bold(Demi Bold)|700 |Bold|800 |Extra Bold(Ultra Bold)|900 |Black (Heavy) 注：为什么说是通常呢？因为在有些字库下是有差异的，比如在Adobe Typekit字库中对字重描述的划分列表中，它列出Heavy指的是800而不是900。另外，在我们日常使用的Photoshop和Sketch里面，Ultra Light是100，而Thin是200。 css中还有bolder、lighterbolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。其值通常是根据下表计算而得的：|继承值|bolder所代表的字重|lighter所代表的字种||：—：|：—：|：—：||100|400|100||200|400|100||300|400|100||400|700|100||500|700|100||600|900|400||700|900|400||800|900|700||900|900|700| 字体匹配算法如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染： 如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。 如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。 如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。 如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行第二条所需字重大于500的规则。 衬线字体（serif）和无衬线字体（sans serif）西方国家字母体系分为两类：衬线字体（serif）以及无衬线体（sans serif）。衬线字体，意思是在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。无衬线体是无衬线字体，没有这些额外的装饰，而且笔画的粗细差不多。 从Android 8.0(API 26)开始，支持通过资源文件的方式引用字库详见android O 在xml文件中引用字体]]></content>
      <categories>
        <category>Android</category>
        <category>字体</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git子项目错误汇总]]></title>
    <url>%2F2019%2F01%2F17%2Fgit%2Fgit-submodule-errors.html</url>
    <content type="text"><![CDATA[错误收集clone代码报错-fatal: reference is not a tree: 85e5c187f03d9c10889dfbddd8adf4d87af2c71f12345678910111213141516171819$ git clone --recursive -b src https://github.com/jnnjiang/jnnjiang.github.io.git blogCloning into &apos;blog6&apos;...remote: Enumerating objects: 803, done.remote: Counting objects: 100% (803/803), done.remote: Compressing objects: 100% (351/351), done.remote: Total 803 (delta 289), reused 763 (delta 251), pack-reused 0Receiving objects: 100% (803/803), 4.58 MiB | 661.00 KiB/s, done.Resolving deltas: 100% (289/289), done.Checking connectivity... done.Submodule &apos;themes/next&apos; (https://github.com/jnnjiang/hexo-theme-next.git) registered for path &apos;themes/next&apos;Cloning into &apos;themes/next&apos;...remote: Enumerating objects: 1, done.remote: Counting objects: 100% (1/1), done.remote: Total 5364 (delta 0), reused 0 (delta 0), pack-reused 5363Receiving objects: 100% (5364/5364), 5.09 MiB | 812.00 KiB/s, done.Resolving deltas: 100% (3293/3293), done.Checking connectivity... done.fatal: reference is not a tree: 85e5c187f03d9c10889dfbddd8adf4d87af2c71fUnable to checkout &apos;85e5c187f03d9c10889dfbddd8adf4d87af2c71f&apos; in submodule path &apos;themes/next&apos; 原因还不是很清楚，解决办法：去之前提交项目的根目录下，执行git status123456789101112$ cd blog$ git statusOn branch srcYour branch is up-to-date with &apos;origin/src&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: themes/next (new commits, untracked content)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 发现有untracked文件，执行git diff12345678$ git diff themes/next/diff --git a/themes/next b/themes/nextindex 85e5c18..f8281ed 160000--- a/themes/next+++ b/themes/next@@ -1 +1 @@-Subproject commit 85e5c187f03d9c10889dfbddd8adf4d87af2c71f+Subproject commit f8281ed747fe94399fd8dbf4d66d6ac5b7faf8ff-dirty 发现确实有一个85e5c187f03d9c10889dfbddd8adf4d87af2c71f提交。而f8281ed747fe94399fd8dbf4d66d6ac5b7faf8ff对应的是现在github上项目的HEAD。执行下面的命令，将这个改动提交上去123$ git add themes/next/$ git commit -m &quot;add submodule changes&quot;$ git push origin src:src 此时再重新clone项目就不会报错了123456789101112131415161718$ git clone --recursive -b src https://github.com/jnnjiang/jnnjiang.github.io.git blog7Cloning into &apos;blog7&apos;...remote: Enumerating objects: 806, done.remote: Counting objects: 100% (806/806), done.remote: Compressing objects: 100% (354/354), done.remote: Total 806 (delta 290), reused 765 (delta 251), pack-reused 0Receiving objects: 100% (806/806), 4.58 MiB | 938.00 KiB/s, done.Resolving deltas: 100% (290/290), done.Checking connectivity... done.Submodule &apos;themes/next&apos; (https://github.com/jnnjiang/hexo-theme-next.git) registered for path &apos;themes/next&apos;Cloning into &apos;themes/next&apos;...remote: Enumerating objects: 1, done.remote: Counting objects: 100% (1/1), done.remote: Total 5364 (delta 0), reused 0 (delta 0), pack-reused 5363Receiving objects: 100% (5364/5364), 5.09 MiB | 1.01 MiB/s, done.Resolving deltas: 100% (3293/3293), done.Checking connectivity... done.Submodule path &apos;themes/next&apos;: checked out &apos;f8281ed747fe94399fd8dbf4d66d6ac5b7faf8ff&apos; git status时一直提示有未跟踪的文件:(new commits, untracked content)1234567891011$ git statusOn branch srcYour branch is up-to-date with &apos;origin/src&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: themes/next (new commits, untracked content)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 进入子项目themes/next发现文件夹下有一个patch12345678$ cd themes/next$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) 0001-change-styles-of-pre-article-and-next-article.patch 删除就没问题了。 针对子项目中未跟踪的文件，可以分两种情况处理： 如果项目目中的文件是不需要提交的，则删除即可。 如果是需要提交的的，则先在子项目提交，再在主项目提交。 然后在主项目上执行git status会发现，没有那个提示了：12345$ git statusOn branch srcYour branch is ahead of &apos;origin/src&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working directory clean]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git子项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 多个终端同步开发的问题]]></title>
    <url>%2F2019%2F01%2F16%2Funcategorized%2Fhexo-multi-peers.html</url>
    <content type="text"><![CDATA[一端如果想在多个终端上开发博客，并且还要保持代码同步，可以按照一下步骤操作1.在已经搭建好Hexo环境的本地项目上创建分支src，需要先在跟目录下执行git init，把本地代码变成一个git项目。默认是在master分支，执行1git checkout -b src 将项目切换到src分支，因为我们在执行hexo d的时候，默认是将public文件夹下的内容提交到git项目的master分支上。2.将项目提交到github上123git add .git commit -m &quot;first commit&quot;git push origin src:src 3.登录github，就会在项目下看到我们刚才的提交记录。至此，项目的源码就得到保存了。 另一端4.在另一端同步代码1git clone -b src 项目地址 5.安装必要的依赖1npm install hexo 6.然后就可以编辑同步博客内容了12hexo ghexo d 7.提交源码123git add .git commit -m &quot;first commit&quot;git push origin src:src 其他端操作方式同另一端 Tips1.如果电脑上之前配置了git账户，那么执行hexo d时，默认会使用已经配置的git的账户。关于.deploy中git账户的配置，可以参见hexo+github搭建自己的博客中配置.deploy中git账户一节。]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo配置-打造自己的博客（基于landscape主题）]]></title>
    <url>%2F2019%2F01%2F14%2Fhexo%2Fhexo%2Bconfig.html</url>
    <content type="text"><![CDATA[_config.yml_config.yml 采用YAML语法格式，具体语法自行学习 。_config.yml 文件中的内容，并对主要参数做简单的介绍:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述author: John Doe #作者language: #语言timezone: #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.com #你的站点Urlroot: / #站点的根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式 permalink_defaults: #永久链接中各部分的默认值# Directory source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹 archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post #预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #是否显示草稿post_asset_folder: false #是否启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章highlight: #内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式 # Pagination## Set per_page to 0 to disable paginationper_page: 10 #分页数量pagination_dir: page # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html# 部署部分的设置deploy: type: #类型，常用的git 修改Banner图替换themes/landscape/source/css/images/banner.jpg下的图片即可。注意命名一定要是banner.jpg 修改标题、副标题、博客描述、语言修改根目录下_config.yml文件12345678# Sitetitle: Michelle&apos;s Homesubtitle: 纳纳的小窝description: 学习笔记、工作心得keywords:author: 江纳纳language: zh-CN //必须和主题中languages包中文件名相同timezone: 修改之后： 对source文件夹下文章md文件分类我的是按月归档的。操作步骤如下：1.修改_config.yml文件1new_post_name: :year/:month/:title.md 2.修改文章模版，增加 permalink一项就好了。文章的模版在scaffolds/post.md，内容修改如下：12345678---title: &#123;&#123; title &#125;&#125;permalink: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: toc: false--- 而我们使用hexo new post [title]创建文章的时候，应注意把标题里的空格换为-。参考链接 给文章设置目录1.修改article.ejs路径：themes/landscape/layout/_partial/article.ejs修改前： 12345678910111213&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link)&#123; %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;!-- Table of Contents --&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;/div&gt; 修改后：1234567891011121314151617181920&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link)&#123; %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;!-- 文章目录 --&gt; &lt;% if(!index &amp;&amp; post.toc)&#123; %&gt; //!index:表示主页不显示 post.toc表示Font-Formatter中设置了toc &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;目录&lt;/strong&gt; &lt;%- toc(post.content,&#123;list_number:false&#125;) %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;!-- Table of Contents --&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;/div&gt; 2.设置目录的样式文件路径：themes/landscape/source/css/_partial/article.styl，在末尾添加：12345678910111213141516171819202122/*toc*/.toc-article background #eee border 1px solid #bbb border-radius 3px margin 1.5em 0 0.3em 0 padding 1.2em 1em 0 1em max-width 28%.toc-title font-size 120%#toc line-height 1em font-size 0.9em /*float right*/ //该属性的作用是使目录悬浮到右侧，注释掉之后，目录默认显示在标题和内容之间 .toc padding 0 margin 1em line-height 1.8em li list-style-type none .toc-child margin-left 1em 插入图片远程图片将图片上传到某个远程服务器上，然后通过引用图片地址的方式加载图片，引用方式如下：1![](https://b-ssl.duitang.com/uploads/item/201411/07/20141107164412_v284V.thumb.1900_0.jpeg) 注：这是markdown默认的引用方式 优点：引用方便，且兼容性好缺点：依赖于网络，加载速度可能受影响 本地图片加载本地图片有两种方式： 在source下面创建一个images 把图片都放到里面，通过如下方式引用1![](/images/hexo-image.jpeg) 在source/_posts/下生成和文件名相同的文件夹step1：将根目录下_config.yml中有post_asset_folder: true 如果是flase 改成truestep2:新建文件insert-image1hexo new &quot;insert-image&quot; 此时会在source/_posts/目录下生成和insert-image同名的文件夹。1234|--source |--_posts |--insert-image |--insert-image.md 将图片放入该文件夹即可。12345|--source |--_posts |--insert-image |--hexo-image.jpeg |--insert-image.md 引用方式一：1![](hexo-image.jpeg) 注：括号内只需要填入文件名即可。 引用方式二：1&#123;% asset_img hexo-image.jpeg image %&#125; 注：引用方式二是hexo引擎所支持的方式，并不是markdown语法。 修改menu，添加关于1.修改配置文件_config.yml，在菜单中添加关于路径：themes/landscape/_config.yml12345678# Headermenu: 首页: / 归档: /archives #分类: /categories #标签: /tags/ #随笔: /essay 关于: /about 注意：menu下的菜单项默认是英文，因为我们已经设置了语言为中文，但是显示上并没有变化，这是因为，在landscape主题的语言包中，并没有适配菜单项，所以直接改成中文就可以了，不过这样对以后想适配多语言就比较麻烦了，只能算是当前的一个临时方案。 2.创建页面1hexo new page &quot;about&quot; 此时source目录下会生成about的文件夹12345|--source |--_posts |--about |--index |--index.md 在index.md文件中添加关于的信息即可。 添加分类1.修改模板scaffolds/post.md123456---title: &#123;&#123; title &#125;&#125;permalink: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:--- 2.创建文件1hexo new test-category 3.在font-formatter中添加分类：12345title: test-categorypermalink: test-categorydate: 2019-01-14 15:55:55categories: - hexo config 注意：一篇文章只能属于一个分类，如果写成如下形式：123456title: test-categorypermalink: test-categorydate: 2019-01-14 15:55:55categories: - hexo config - category config 则该文章分类属于`/hexo config/category config/ 添加标签1.修改模板scaffolds/post.md1234567---title: &#123;&#123; title &#125;&#125;permalink: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 2.创建文件1hexo new test-category 3.在font-formatter中添加分类：1234567title: test-categorypermalink: test-categorydate: 2019-01-14 15:55:55categories:tags: - aa - bb 注意：虽然一篇文章只能属于一个分类，但是却可以有多个标签 分类、标签显示文章数将themes/landscape/_config.yml中show_count参数设成true123# widget behaviorarchive_type: &apos;monthly&apos;show_count: true 修改前：修改后： 给首页文件增加阅读全文方式一：使用&lt;!--more--&gt; 标记这个只要在文章中加上&lt;!--more--&gt; 标记，该标记以后部分就不在显示了，只有展开全部才显示，这是hexo定义的。这样每次添加这个标记有点麻烦，也可以自定义添加 方式二：自定义添加缺点：可能导致排版比较混乱1.修改文件themes/landscape/layout/_partial/article.ejs12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link)&#123; %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;!-- 文章目录 --&gt; &lt;% if(!index &amp;&amp; post.toc)&#123; %&gt; &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;目录&lt;/strong&gt; &lt;%- toc(post.content,&#123;list_number:true&#125;) %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;!--摘要--&gt; &lt;% var br = post.content.indexOf(&apos;\n&apos;) %&gt; &lt;% if(br &lt; 0 || !index) &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- post.content.substring(0, br) %&gt; &lt;% if (theme.excerpt_link) &#123; %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- post.path %&gt;#more&quot;&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;!-- Table of Contents --&gt; &lt;!--&lt;%- post.content %&gt;--&gt; &lt;% &#125; %&gt; &lt;/div&gt; 在class article-entry的else部分，增加摘要判断。 参考：站点首页不显示文章全文自动添加read more标记 去掉首页文章日期后的分类信息修改文件themes/landscape/layout/_partial/article.ejs1234&lt;div class=&quot;article-meta&quot;&gt; &lt;%- partial(&apos;post/date&apos;, &#123;class_name: &apos;article-date&apos;, date_format: null&#125;) %&gt; &lt;!--&lt;%- partial(&apos;post/category&apos;) %&gt;首页文章日期后面不显示分类--&gt;&lt;/div&gt; 默认：修改后： 关于，去掉文章中的日期Landscape主题，通过hexo new page pagename创建的页面，默认是显示日期的，但是像关于这种页面，我们并不希望它显示日期，那么就需要修改article.ejs，控制日期的显示1.修改scaffolds/page.md，自定义变量show_date，将其值设为false12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;show_date: false--- 2.修改themes/landscape/layout/_partial/article.ejs，具体如下：修改前：1&lt;%- partial(&apos;post/date&apos;, &#123;class_name: &apos;article-date&apos;, date_format: null&#125;) %&gt; 修改后：123456&lt;% if(typeof(post.show_date)!= &quot;undefined&quot; &amp;&amp; !post.show_date)&#123; %&gt; //前一个条件是判断变量是否存在，因为之前写的文章里并没有这个变量，但是却是要显示日期的。 &lt;% &#125;else&#123; %&gt; &lt;%- partial(&apos;post/date&apos;, &#123;class_name: &apos;article-date&apos;, date_format: null&#125;) %&gt; &lt;!--&lt;%- partial(&apos;post/category&apos;) %&gt;首页文章日期后面不显示分类--&gt; &lt;% &#125; %&gt; 侧边栏显示分类安装分类插件：1npm install hexo-generator-category --save 卸载可执行1npm uninstall hexo-generator-category --save 那样点击侧边栏的分类，将会提示找不到网页 侧边栏显示标签安装标签插件：1npm install hexo-generator-tag --save 标签、分类别名为了避免在分类或标签的url中产生中文，可以设置标签、分类的别名1234567category_map: #冒号前面是分类名称，后面是访问路径 Android: Android Java: Java Hexo: Hexo Web前端: Web Linux: linux Mac: mac 123456789101112131415tag_map: Android Studio: android-studio Android API: android-API Android Widget: android-widget Android 源码分析: android-source JDK: JDK Hexo建站: hexo-blog Hexo 配置: hexo-config Hexo 主题: hexo-themes EJS教程: ejs HTML5: html CSS3: css JS: js git: git 常用工具: tools 使用：12345678910---title: hexo配置-打造自己的博客（基于landscape主题）permalink: hexo+configtoc: truedate: 2019-01-14 16:15:43tags: - Hexo 配置categories: - Hexo--- 这样在博客中显示的是Hexo 配置，在url中显示的是hexo-config 站内搜索https://segmentfault.com/a/1190000011917419这个应该是和主题相关的，好像需要自己写待续。。。 多语言支持分享config文件参数说明其他：主题修改相关：https://www.jianshu.com/p/b96fd206571a 在菜单中怎讲category和tags，网上查到的这几篇文章并不起作用，还需要再查查看https://mrcxt.github.io/hexo/%E8%A7%A3%E5%86%B3hexo%E4%B8%8B%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/https://blog.csdn.net/qq_32337109/article/details/78755662https://www.jianshu.com/p/a6a72ed6aa2a 统计评论othershttps://www.jianshu.com/p/b96fd206571a]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建自己的博客]]></title>
    <url>%2F2019%2F01%2F14%2Fhexo%2Fhexo%2Bgithub.html</url>
    <content type="text"><![CDATA[hexo 简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 环境搭建安装nodejsLinux1.下载nodejs，最新版本10.15.0简单说就是解压后，在bin文件夹中已经存在node以及npm，如果你进入到对应文件的中执行命令行一点问题都没有，不过不是全局的，所以将这个设置为全局就好了。2.解压到当前目录（Download）3.移动到指定目录1mv Download/node-v10.15.0 Tools/nodejs 4.查看版本1234$ cd Tool/nodejs/bin/$ ls$ ./node -vv10.15.0 // 我的版本 5.建立软链接，使其全局有效12$ ln -s /home/nana/Tools/nodejs/bin/node /usr/local/bin/node$ ln -s /home/nana/Tools/nodejs/bin/npm /usr/local/bin/npm 6.查看版本12$ node -vv10.15.0 Mac1.1.下载nodejs，最新版本10.15.02.双击安装（默认会安装到/usr/local/bin/下）3.查看版本12$ node -vv10.15. 安装gitLinux安装git：1sudo apt-get install git 安装gitk:1sudo apt-get install gitk Mac虽然Mac自带git，但是为了方便后续用gitk查看代码提交情况，建议，用brew重新安装带gitk的git1.如果没有安装brew，则需要先安装brew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.查看系统git的位置12$ which git/usr/bin/git 3.重新安装git12$ brew update$ brew install git 4.再次查看git的位置12$ which git/usr/local/bin/git 安装hexo1npm install -g hexo-cli 建站安装完成后，执行下列命令，hexo将会在指定文件夹中新建所需要的文件123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这里尤其要中注意_config.yml文件，在这个文件里，可以配置网站的大部分参数。配置详见hexo配置 预览12hexo ghexo s 关联github1.在github上创建项目，项目名为{username}.github.io 部署 打开 Hexo 博客主配置文件 _config.yml，找到 deploy 属性，作如下配置： 1234deploy: type: git repository: https://github.com/jnnjiang/jnnjiang.github.io.git branch: master 在.deploy_git/下配置github账号： 12git config user.name &quot;xxxx&quot;git config user.email &quot;xxxx&quot; 如果没有.deploy_git/文件也不用担心，执行下hexo d就会生成，执行的过程中会报错，不用担心，按照步骤2配置账号信息即可。 执行如下命令：12hexo ghexo d 按照提示输入github账号的用户名和密码即可。 4.如果不想每次都输入用户名和密码，可以通过配置./git/config实现：1git config credential.helper store 然后部署时输入一次用户名和密码即可，此时会在user下面生成.git-credentials文件。以后在部署就不用输入用户名和密码了。 配置.deploy中git账户使用hexo d将代码推送到github时，如果之前配置过git账户，但是提交是想用新的git账户，而在没有执行hexo d之前，.deploy文件夹是不会生成的，这种情况下改怎么办呢？1.执行hexo d推送一次代码。需要输入用户名和密码的时候，输入新账户的2.登录github，将项目的默认分支设置成其他分支，然后删除master分支（blog默认是推送到master分支的，否则无法正常工作）3.进入本地.deploy/ 文件夹，配置新的git账户新123git config user.name &quot;xxx&quot;git config user.email &quot;xxx&quot;git config credential.hepler store 4.将.deploy/.git/config文件保存到项目外5.删除.deploy/.git文件夹6.重新创建仓库12cd .deploygit init 7.将第4步中保存的config文件复制到.deploy/.git/下。8.执行hexo d重新推送代码，这时候会发现远端存在一个干净的分支，用户名也变成新的了9.切换默认分支。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统安装gitk]]></title>
    <url>%2F2019%2F01%2F12%2Fmac%2Fgitk-mac.html</url>
    <content type="text"><![CDATA[gitk for mac1.如果没有安装brew，则需要先安装brew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.由于系统自带的git中没有gitk，所以需要重新安装 1)查看系统git的位置 12$ which git/usr/bin/git 2)重新安装git 12$ brew update$ brew install git 3)再次查看git的位置 12$ which git/usr/local/bin/git 安装成功 3.在git项目中，执行gitk命令，就可以看到图形化界面了。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F11%2Fhexo%2Fhexo-hello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于测试：我的名字，联系方式]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
